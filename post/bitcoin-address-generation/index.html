<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.48" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="OPSXCQ Blog">
<title>Bitcoin address generation in pure python - OPSXCQ Blog</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="https://strm.sh/">[OPSXCQ Blog]</a>
    <span class="caret"># _</span>
    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2018-09-14">September 14, 2018</time></span>



    <br>
    <span class="key">tags:</span>
    <span class="val">

        <a href="/tags/cryptography">cryptography</a>

        <a href="/tags/eliptic%20curves">eliptic curves</a>

        <a href="/tags/bitcoin">bitcoin</a>

        <a href="/tags/python">python</a>

    </span>

  </div>
  <h1 class="headline" itemprop="headline">Bitcoin address generation in pure python</h1>
  <section class="body" itemprop="articleBody">
    

<p>Bitcoin address generation can be split in 4 steps listed bellow:</p>

<ul>
<li>Generating a secure private key.</li>
<li>Calculate the public key from the private key.</li>
<li>Encode the public key as a bitcoin address.</li>
<li>Encode the private key in the WIF format.</li>
</ul>

<h2 id="step-1-generate-ecdsa-keypair">Step 1: Generate ECDSA Keypair</h2>

<p>The very first step is to select a good and secure number, for this example we
won&rsquo;t use one, instead we will simply get the random from the system. An example
why is important a good and secure random number is <a href="https://strm.sh/post/bitcoin-transaction-nonce-reuse/">written in this post about
cracking some bitcoin private
keys</a>, the bug isn&rsquo;t
located in the key generation, but in the random used to sign the transactions,
but the point is the same, weak PRNG (Pseudo-random number generators) can put
everything in risk.</p>

<p>Using this PRNG can be done with:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">    randomBytes = os.urandom(<span style="color:#3677a9">32</span>)</code></pre></div>
<h2 id="step-2-calculate-the-public-key">Step 2: Calculate the public key</h2>

<p>Since bitcoin uses <strong>spec256k1</strong> the only thing that we need to do is multiply
it by the initial point in the curve by the <strong>private key</strong> to obtain the public
key.</p>

<p>Next step is to convert the key to a byte array and hash it, first with
<strong>SHA-256</strong> then with <strong>RIPEMD-160</strong>. Then we prepend the hashed public key with
<code>0x00</code> if the target network is the <em>mainnet</em>, if the address generated meant to
be used in the <em>testnet</em> <code>0x6f</code> must be prepended.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">SPEC256k1 = Point()
pk = <span style="color:#24909d">int</span>.from_bytes(privkey, <span style="color:#ed9d13">&#34;big&#34;</span>)
hash160 = ripemd160(sha256((SPEC256k1 * pk).toBytes()))
address = <span style="color:#ed9d13">b</span><span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\x00</span><span style="color:#ed9d13">&#34;</span> + hash160</code></pre></div>
<h3 id="checksum">Checksum</h3>

<p>Then the only thing left to add in the address it the checksum, it is appended
to the address and is the last 4 bytes of the double <strong>SHA-256</strong> of the address
calculated above.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">address = b58(address + sha256(sha256(address))[:<span style="color:#3677a9">4</span>])</code></pre></div>
<p>Then just encode the key bytes to <strong>base58</strong> and you have your Bitcoin address !</p>

<h3 id="public-key-compression">Public key compression</h3>

<p>When representing the public key as a number is possible to compress it
considering that the key is $x$ and $y$ in the eliptic curve and since we have
the equation, and given an $x$ value, there is only two values for $y$ possible.
So to compress a public key, if $y$ is odd, <code>0x03</code> is appended to the $x$ value,
else, <code>0x02</code> is appended.</p>

<h1 id="step-4-encode-the-private-key-in-the-wif-format">Step 4: Encode the private key in the WIF format</h1>

<p>To create a WIF () key from the private key bytes is far simples than the
previous steps, first prepend the byte <code>0x80</code> to the wif, then append the
private key bytes. After, append the checksum, that is the last 4 bytes of the
double <strong>SHA-256</strong> of the partial wif key that we already have calculated.</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">wif = <span style="color:#ed9d13">b</span><span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\x80</span><span style="color:#ed9d13">&#34;</span> + privkey
wif = b58(wif + sha256(sha256(wif))[:<span style="color:#3677a9">4</span>])
<span style="color:#6ab825;font-weight:bold">return</span> wif</code></pre></div>
<h1 id="source-code">Source code</h1>

<p>This is a reference script, it depends on <strong>Python 3</strong> to run and is self
contained, it means no external dependencies are required to run it. One example
of its output:</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-raw" data-lang="raw">$ ./bitcoin-address-generator.py 
Address: 18jJh1kSPJqbXtMB51SyczgcHL1drkDgxV
Privkey: 5JTEF3GHpDAin1caVqfznHU8T1jscHVVD5SMFALBTC4no2J4DqX</code></pre></div><div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">os</span>
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">hashlib</span>


<span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">sha256</span>(data):
    digest = hashlib.new(<span style="color:#ed9d13">&#34;sha256&#34;</span>)
    digest.update(data)
    <span style="color:#6ab825;font-weight:bold">return</span> digest.digest()


<span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">ripemd160</span>(x):
    d = hashlib.new(<span style="color:#ed9d13">&#34;ripemd160&#34;</span>)
    d.update(x)
    <span style="color:#6ab825;font-weight:bold">return</span> d.digest()


<span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">b58</span>(data):
    B58 = <span style="color:#ed9d13">&#34;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;</span>

    <span style="color:#6ab825;font-weight:bold">if</span> data[<span style="color:#3677a9">0</span>] == <span style="color:#3677a9">0</span>:
        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#ed9d13">&#34;1&#34;</span> + b58(data[<span style="color:#3677a9">1</span>:])

    x = <span style="color:#24909d">sum</span>([v * (<span style="color:#3677a9">256</span> ** i) <span style="color:#6ab825;font-weight:bold">for</span> i, v <span style="color:#6ab825;font-weight:bold">in</span> <span style="color:#24909d">enumerate</span>(data[::-<span style="color:#3677a9">1</span>])])
    ret = <span style="color:#ed9d13">&#34;&#34;</span>
    <span style="color:#6ab825;font-weight:bold">while</span> x &gt; <span style="color:#3677a9">0</span>:
        ret = B58[x % <span style="color:#3677a9">58</span>] + ret
        x = x // <span style="color:#3677a9">58</span>

    <span style="color:#6ab825;font-weight:bold">return</span> ret


<span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Point</span>:
    <span style="color:#6ab825;font-weight:bold">def</span> __init__(self,
        x=<span style="color:#3677a9">0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</span>,
        y=<span style="color:#3677a9">0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</span>,
        p=<span style="color:#3677a9">2</span>**<span style="color:#3677a9">256</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">32</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">9</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">8</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">7</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">6</span> - <span style="color:#3677a9">2</span>**<span style="color:#3677a9">4</span> - <span style="color:#3677a9">1</span>):
        self.x = x
        self.y = y
        self.p = p

    <span style="color:#6ab825;font-weight:bold">def</span> __add__(self, other):
        <span style="color:#6ab825;font-weight:bold">return</span> self.__radd__(other)

    <span style="color:#6ab825;font-weight:bold">def</span> __mul__(self, other):
        <span style="color:#6ab825;font-weight:bold">return</span> self.__rmul__(other)

    <span style="color:#6ab825;font-weight:bold">def</span> __rmul__(self, other):
        n = self
        q = None

        <span style="color:#6ab825;font-weight:bold">for</span> i <span style="color:#6ab825;font-weight:bold">in</span> <span style="color:#24909d">range</span>(<span style="color:#3677a9">256</span>):
            <span style="color:#6ab825;font-weight:bold">if</span> other &amp; (<span style="color:#3677a9">1</span> &lt;&lt; i):
                q = q + n
            n = n + n

        <span style="color:#6ab825;font-weight:bold">return</span> q

    <span style="color:#6ab825;font-weight:bold">def</span> __radd__(self, other):
        <span style="color:#6ab825;font-weight:bold">if</span> other <span style="color:#6ab825;font-weight:bold">is</span> None:
            <span style="color:#6ab825;font-weight:bold">return</span> self
        x1 = other.x
        y1 = other.y
        x2 = self.x
        y2 = self.y
        p = self.p

        <span style="color:#6ab825;font-weight:bold">if</span> self == other:
            l = <span style="color:#24909d">pow</span>(<span style="color:#3677a9">2</span> * y2 % p, p-<span style="color:#3677a9">2</span>, p) * (<span style="color:#3677a9">3</span> * x2 * x2) % p
        <span style="color:#6ab825;font-weight:bold">else</span>:
            l = <span style="color:#24909d">pow</span>(x1 - x2, p-<span style="color:#3677a9">2</span>, p) * (y1 - y2) % p

        newX = (l ** <span style="color:#3677a9">2</span> - x2 - x1) % p
        newY = (l * x2 - l * newX - y2) % p

        <span style="color:#6ab825;font-weight:bold">return</span> Point(newX, newY)

    <span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">toBytes</span>(self):
        x = self.x.to_bytes(<span style="color:#3677a9">32</span>, <span style="color:#ed9d13">&#34;big&#34;</span>)
        y = self.y.to_bytes(<span style="color:#3677a9">32</span>, <span style="color:#ed9d13">&#34;big&#34;</span>)
        <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#ed9d13">b</span><span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\x04</span><span style="color:#ed9d13">&#34;</span> + x + y


<span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">getPublicKey</span>(privkey):
    SPEC256k1 = Point()
    pk = <span style="color:#24909d">int</span>.from_bytes(privkey, <span style="color:#ed9d13">&#34;big&#34;</span>)
    hash160 = ripemd160(sha256((SPEC256k1 * pk).toBytes()))
    address = <span style="color:#ed9d13">b</span><span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\x00</span><span style="color:#ed9d13">&#34;</span> + hash160

    address = b58(address + sha256(sha256(address))[:<span style="color:#3677a9">4</span>])
    <span style="color:#6ab825;font-weight:bold">return</span> address


<span style="color:#6ab825;font-weight:bold">def</span> <span style="color:#447fcf">getWif</span>(privkey):
    wif = <span style="color:#ed9d13">b</span><span style="color:#ed9d13">&#34;</span><span style="color:#ed9d13">\x80</span><span style="color:#ed9d13">&#34;</span> + privkey
    wif = b58(wif + sha256(sha256(wif))[:<span style="color:#3677a9">4</span>])
    <span style="color:#6ab825;font-weight:bold">return</span> wif


<span style="color:#6ab825;font-weight:bold">if</span> __name__ == <span style="color:#ed9d13">&#34;__main__&#34;</span>:
    randomBytes = os.urandom(<span style="color:#3677a9">32</span>)
    <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;Address: &#34;</span> + getPublicKey(randomBytes))
    <span style="color:#6ab825;font-weight:bold">print</span>(<span style="color:#ed9d13">&#34;Privkey: &#34;</span> + getWif(randomBytes))</code></pre></div>
<h1 id="references">References</h1>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">Eliptic curves in cryptography</a></li>
<li><a href="https://en.bitcoin.it/wiki/Address">Bitcoin Address documentation</a></li>
</ul>

  </section>
</article>

</main>

</div>

<footer>
  <div class="container">
      <span class="copyright">&copy; 2019 OPSXCQ Blog - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("End Jax",function () {
  var BROWSER = MathJax.Hub.Browser;
  var jax = "HTML-CSS";
  if (BROWSER.isMSIE && BROWSER.hasMathPlayer) jax = "NativeMML";
  if (BROWSER.isFirefox) jax = "SVG";
  if (BROWSER.isSafari && BROWSER.versionAtLeast("5.0")) jax = "NativeMML";
  return MathJax.Hub.setRenderer(jax);
});
</script>

<script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
    extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
    });
    MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-43399052-10"></script>
<script>
window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-43399052-10');
</script>


</body>
</html>

