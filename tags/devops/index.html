<!DOCTYPE html>
<html lang="en-us">
<head>
<meta charset="utf-8">
<meta name="description" content="">
<meta name="generator" content="Hugo 0.48" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="OPSXCQ Blog">
<title>Devops - OPSXCQ Blog</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="https://strm.sh/">[OPSXCQ Blog]</a>
    <span class="caret"># _</span>
    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">

<main role="main" class="article-list">
  <h1 class="list-title">Devops</h1>
  
    <article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/docker-network-restrictions-with-tor/">Docker network restrictions with Tor</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2019-02-14">February 14, 2019</time></span>

  </div>
  <section class="summary">
    Image the following usecase, you have an application and want to for its traffict through Tor, exclusively. If if is running on your computer like a normal application, it is simple, just add some iptables rules. But in the container world things are different, specially if you want to escalate it through several machines.
Here will be explored an usecase of an isolated container that can only communicate with a proxy container that has access to the Tor network.  <a href="/post/docker-network-restrictions-with-tor/">Read More...</a>
  </section>
</article>

  
    <article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/monero-mining-live-usb/">Mining monero using live a live usb linuxkit build</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2018-09-12">September 12, 2018</time></span>

  </div>
  <section class="summary">
    Linuxkit is a good tool to create immutable Linux systems, so why don&rsquo;t use it to build a Monero mining live distro ? The only thing needed to build an Linux with Linuxkit is a yml file containing the system information. It can be divided in 5 main sections:
 kernel init onboot - applications that will run when the Linux boot (after init) services - services that will run on this system files - any extra files that you need to copy into your iso (like keys or configs)  Based on these principles, bellow is the configuration of a miner that will boot and start mining rigth away.  <a href="/post/monero-mining-live-usb/">Read More...</a>
  </section>
</article>

  
    <article class="list-item" itemscope itemtype="http://schema.org/Blog">
  <h2 class="headline" itemprop="headline"><a href="/post/cron-tasks-inside-docker/">Running Cron tasks on docker - The correct way</a></h2>
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2018-09-06">September 06, 2018</time></span>

  </div>
  <section class="summary">
    While is perfectly possible to use cron inside a container, I strongly advise you to don&rsquo;t do it. Some of the most important points on why is a bad practice to run cron inside a container:
Your tasks need to be ephemeral as your containers We live in the immutable infrastructure era, there is no need to worry about cleaning up everything before or after your tasks run. Make your scheduled tasks ephemeral as your containers, if something goes wrong, you can inspect the precise state that the container was left.  <a href="/post/cron-tasks-inside-docker/">Read More...</a>
  </section>
</article>

  
</main>
</div>

<footer>
  <div class="container">
      <span class="copyright">&copy; 2019 OPSXCQ Blog - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

<script type="text/x-mathjax-config">
MathJax.Hub.Register.StartupHook("End Jax",function () {
  var BROWSER = MathJax.Hub.Browser;
  var jax = "HTML-CSS";
  if (BROWSER.isMSIE && BROWSER.hasMathPlayer) jax = "NativeMML";
  if (BROWSER.isFirefox) jax = "SVG";
  if (BROWSER.isSafari && BROWSER.versionAtLeast("5.0")) jax = "NativeMML";
  return MathJax.Hub.setRenderer(jax);
});
</script>

<script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
    tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
    extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
    });
    MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-43399052-10"></script>
<script>
window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-43399052-10');
</script>


</body>
</html>

